import {
  AbstractTypeResolver,
  FieldResolver,
  GetGen,
  HasGen3,
  NeedsResolver,
  AuthorizeResolver,
  GetGen3,
} from "../typegenTypeHelpers";
import { NexusArgDef } from "./args";
import {
  AllNexusOutputTypeDefs,
  NexusWrappedType,
  AllNexusInputTypeDefs,
} from "./wrapping";
import { BaseScalars } from "./_types";
import { GraphQLFieldResolver } from "graphql";
export interface CommonFieldConfig {
  /**
   * Whether the field can be null
   * @default (depends on whether nullability is configured in type or schema)
   */
  nullable?: boolean;
  /**
   * The description to annotate the GraphQL SDL
   */
  description?: string | null;
  /**
   * Info about a field deprecation. Formatted as a string and provided with the
   * deprecated directive on field/enum types and as a comment on input fields.
   */
  deprecation?: string;
  /**
   * Whether the field is list of values, or just a single value.
   *
   * If list is true, we assume the field is a list. If list is an array,
   * we'll assume that it's a list with the depth. The boolean indicates whether
   * the field is required (non-null).
   *
   * @see TODO: Examples
   */
  list?: true | boolean[];
}
export interface CommonOutputFieldConfig<
  TypeName extends string,
  FieldName extends string
> extends CommonFieldConfig {
  /**
   * Arguments for the field
   */
  args?: Record<string, NexusArgDef<string>>;
  /**
   * Authorization for an individual field. Returning "true"
   * or "Promise<true>" means the field can be accessed.
   * Returning "false" or "Promise<false>" will respond
   * with a "Not Authorized" error for the field. Returning
   * or throwing an error will also prevent the resolver from
   * executing.
   */
  authorize?: AuthorizeResolver<TypeName, FieldName>;
}
export interface OutputScalarConfig<
  TypeName extends string,
  FieldName extends string
> extends CommonOutputFieldConfig<TypeName, FieldName> {
  /**
   * Resolve method for the field
   */
  resolve?: FieldResolver<TypeName, FieldName>;
}
export interface NexusOutputFieldConfig<
  TypeName extends string,
  FieldName extends string
> extends OutputScalarConfig<TypeName, FieldName> {
  type:
    | GetGen<"allOutputTypes">
    | AllNexusOutputTypeDefs
    | NexusWrappedType<AllNexusOutputTypeDefs>;
}
export declare type NexusOutputFieldDef = NexusOutputFieldConfig<
  string,
  any
> & {
  name: string;
  subscribe?: GraphQLFieldResolver<any, any>;
};
/**
 * Ensure type-safety by checking
 */
export declare type ScalarOutSpread<
  TypeName extends string,
  FieldName extends string
> = NeedsResolver<TypeName, FieldName> extends true
  ? HasGen3<"argTypes", TypeName, FieldName> extends true
    ? [ScalarOutConfig<TypeName, FieldName>]
    :
        | [ScalarOutConfig<TypeName, FieldName>]
        | [FieldResolver<TypeName, FieldName>]
  : HasGen3<"argTypes", TypeName, FieldName> extends true
  ? [ScalarOutConfig<TypeName, FieldName>]
  :
      | []
      | [FieldResolver<TypeName, FieldName>]
      | [ScalarOutConfig<TypeName, FieldName>];
export declare type ScalarOutConfig<
  TypeName extends string,
  FieldName extends string
> = NeedsResolver<TypeName, FieldName> extends true
  ? OutputScalarConfig<TypeName, FieldName> & {
      resolve: FieldResolver<TypeName, FieldName>;
    }
  : OutputScalarConfig<TypeName, FieldName>;
export declare type FieldOutConfig<
  TypeName extends string,
  FieldName extends string
> = NeedsResolver<TypeName, FieldName> extends true
  ? NexusOutputFieldConfig<TypeName, FieldName> & {
      resolve: FieldResolver<TypeName, FieldName>;
    }
  : NexusOutputFieldConfig<TypeName, FieldName>;
export interface OutputDefinitionBuilder {
  addField(config: NexusOutputFieldDef): void;
}
export interface InputDefinitionBuilder {
  addField(config: NexusInputFieldDef): void;
}
export interface OutputDefinitionBlock<TypeName extends string>
  extends NexusGenCustomDefinitionMethods<TypeName> {}
/**
 * The output definition block is passed to the "definition"
 * argument of the
 */
export declare class OutputDefinitionBlock<TypeName extends string> {
  protected typeBuilder: OutputDefinitionBuilder;
  protected isList: boolean;
  protected hasAdded: boolean;
  constructor(typeBuilder: OutputDefinitionBuilder, isList?: boolean);
  readonly list: OutputDefinitionBlock<TypeName>;
  string<FieldName extends string>(
    fieldName: FieldName,
    ...opts: ScalarOutSpread<TypeName, FieldName>
  ): void;
  int<FieldName extends string>(
    fieldName: FieldName,
    ...opts: ScalarOutSpread<TypeName, FieldName>
  ): void;
  boolean<FieldName extends string>(
    fieldName: FieldName,
    ...opts: ScalarOutSpread<TypeName, FieldName>
  ): void;
  id<FieldName extends string>(
    fieldName: FieldName,
    ...opts: ScalarOutSpread<TypeName, FieldName>
  ): void;
  float<FieldName extends string>(
    fieldName: FieldName,
    ...opts: ScalarOutSpread<TypeName, FieldName>
  ): void;
  field<FieldName extends string>(
    name: FieldName,
    fieldConfig: FieldOutConfig<TypeName, FieldName>
  ): void;
  protected addScalarField(
    fieldName: string,
    typeName: BaseScalars,
    opts: [] | ScalarOutSpread<TypeName, any>
  ): void;
  protected decorateField(config: NexusOutputFieldDef): NexusOutputFieldDef;
}
export interface ScalarInputFieldConfig<T> extends CommonFieldConfig {
  /**
   * Whether the field is required (non-nullable)
   * @default
   */
  required?: boolean;
  /**
   * The default value for the field, if any
   */
  default?: T;
}
export interface NexusInputFieldConfig<
  TypeName extends string,
  FieldName extends string
> extends ScalarInputFieldConfig<GetGen3<"inputTypes", TypeName, FieldName>> {
  type: GetGen<"allInputTypes"> | AllNexusInputTypeDefs<string>;
}
export declare type NexusInputFieldDef = NexusInputFieldConfig<
  string,
  string
> & {
  name: string;
};
export interface InputDefinitionBlock<TypeName extends string>
  extends NexusGenCustomDefinitionMethods<TypeName> {}
export declare class InputDefinitionBlock<TypeName extends string> {
  protected typeBuilder: InputDefinitionBuilder;
  protected isList: boolean;
  protected hasAdded: boolean;
  constructor(typeBuilder: InputDefinitionBuilder, isList?: boolean);
  readonly list: InputDefinitionBlock<TypeName>;
  string(fieldName: string, opts?: ScalarInputFieldConfig<string>): void;
  int(fieldName: string, opts?: ScalarInputFieldConfig<number>): void;
  boolean(fieldName: string, opts?: ScalarInputFieldConfig<boolean>): void;
  id(fieldName: string, opts?: ScalarInputFieldConfig<string>): void;
  float(fieldName: string, opts?: ScalarInputFieldConfig<number>): void;
  field<FieldName extends string>(
    fieldName: FieldName,
    fieldConfig: NexusInputFieldConfig<TypeName, FieldName>
  ): void;
  protected addScalarField(
    fieldName: string,
    typeName: BaseScalars,
    opts?: ScalarInputFieldConfig<any>
  ): void;
  protected decorateField(config: NexusOutputFieldDef): NexusOutputFieldDef;
}
export interface AbstractOutputDefinitionBuilder<TypeName extends string>
  extends OutputDefinitionBuilder {
  setResolveType(fn: AbstractTypeResolver<TypeName>): void;
}
