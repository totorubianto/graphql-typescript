"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var graphql_1 = require("graphql");
var path_1 = tslib_1.__importDefault(require("path"));
var lang_1 = require("./lang");
var utils_1 = require("./utils");
/**
 * Any common types / constants that would otherwise be circular-imported
 */
exports.SCALAR_TYPES = {
    Int: "number",
    String: "string",
    ID: "string",
    Float: "number",
    Boolean: "boolean",
};
/**
 * This is an approach for handling type definition auto-resolution.
 * It is designed to handle the most common cases, as can be seen
 * in the examples / the simplicity of the implementation.
 *
 * If you wish to do something more complex, involving full
 * AST parsing, etc, you can provide a different function to
 * the `typegenInfo` property of the `makeSchema` config.
 *
 * @param options
 */
function typegenAutoConfig(options) {
    var _this = this;
    return function (schema, outputPath) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var headers, contextType, _a, skipTypes, _backingTypeMap, debug, typeMap, typesToIgnore, typesToIgnoreRegex, allImportsMap, importsMap, backingTypeMap, forceImports, typeSources, builtinScalars, imports, typegenInfo;
        var _this = this;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    headers = options.headers, contextType = options.contextType, _a = options.skipTypes, skipTypes = _a === void 0 ? ["Query", "Mutation", "Subscription"] : _a, _backingTypeMap = options.backingTypeMap, debug = options.debug;
                    typeMap = schema.getTypeMap();
                    typesToIgnore = new Set();
                    typesToIgnoreRegex = [];
                    allImportsMap = {};
                    importsMap = {};
                    backingTypeMap = tslib_1.__assign({}, exports.SCALAR_TYPES, _backingTypeMap);
                    forceImports = new Set(utils_1.objValues(backingTypeMap)
                        .concat(contextType || "")
                        .map(function (t) {
                        var match = t.match(/^(\w+)\./);
                        return match ? match[1] : null;
                    })
                        .filter(function (f) { return f; }));
                    skipTypes.forEach(function (skip) {
                        if (typeof skip === "string") {
                            typesToIgnore.add(skip);
                        }
                        else if (skip instanceof RegExp) {
                            typesToIgnoreRegex.push(skip);
                        }
                        else {
                            throw new Error("Invalid type for options.skipTypes, expected string or RegExp");
                        }
                    });
                    return [4 /*yield*/, Promise.all(options.sources.map(function (source) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var fs, util, readFile, pathOrModule, _a, glob, onlyTypes, alias, typeMatch, resolvedPath, fileContents, e_1, importPath;
                            return tslib_1.__generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        fs = require("fs");
                                        util = require("util");
                                        readFile = util.promisify(fs.readFile);
                                        pathOrModule = source.source, _a = source.glob, glob = _a === void 0 ? true : _a, onlyTypes = source.onlyTypes, alias = source.alias, typeMatch = source.typeMatch;
                                        if (path_1.default.isAbsolute(pathOrModule) &&
                                            path_1.default.extname(pathOrModule) !== ".ts") {
                                            return [2 /*return*/, console.warn("GraphQL Nexus Typegen: Expected module " + pathOrModule + " to be an absolute path to a TypeScript module, skipping.")];
                                        }
                                        _b.label = 1;
                                    case 1:
                                        _b.trys.push([1, 3, , 4]);
                                        resolvedPath = require.resolve(pathOrModule, {
                                            paths: [process.cwd()],
                                        });
                                        if (path_1.default.extname(resolvedPath) !== ".ts") {
                                            resolvedPath = findTypingForFile(resolvedPath, pathOrModule);
                                        }
                                        return [4 /*yield*/, readFile(resolvedPath, "utf-8")];
                                    case 2:
                                        fileContents = _b.sent();
                                        return [3 /*break*/, 4];
                                    case 3:
                                        e_1 = _b.sent();
                                        if (e_1 instanceof Error &&
                                            e_1.message.indexOf("Cannot find module") !== -1) {
                                            console.error("GraphQL Nexus: Unable to find file or module " + pathOrModule + ", skipping");
                                        }
                                        else {
                                            console.error(e_1.message);
                                        }
                                        return [2 /*return*/, null];
                                    case 4:
                                        importPath = (path_1.default.isAbsolute(pathOrModule)
                                            ? relativePathTo(resolvedPath, outputPath)
                                            : pathOrModule).replace(/(\.d)?\.ts/, "");
                                        if (allImportsMap[alias] && allImportsMap[alias] !== importPath) {
                                            return [2 /*return*/, console.warn("GraphQL Nexus Typegen: Cannot have multiple type sources " + importsMap[alias] + " and " + pathOrModule + " with the same alias " + alias + ", skipping")];
                                        }
                                        allImportsMap[alias] = importPath;
                                        if (forceImports.has(alias)) {
                                            importsMap[alias] = [importPath, glob];
                                            forceImports.delete(alias);
                                        }
                                        return [2 /*return*/, {
                                                alias: alias,
                                                glob: glob,
                                                importPath: importPath,
                                                fileContents: fileContents,
                                                onlyTypes: onlyTypes,
                                                typeMatch: typeMatch || defaultTypeMatcher,
                                            }];
                                }
                            });
                        }); }))];
                case 1:
                    typeSources = _b.sent();
                    builtinScalars = new Set(Object.keys(exports.SCALAR_TYPES));
                    Object.keys(typeMap).forEach(function (typeName) {
                        if (typeName.indexOf("__") === 0) {
                            return;
                        }
                        if (typesToIgnore.has(typeName)) {
                            return;
                        }
                        if (typesToIgnoreRegex.some(function (r) { return r.test(typeName); })) {
                            return;
                        }
                        if (backingTypeMap[typeName]) {
                            return;
                        }
                        if (builtinScalars.has(typeName)) {
                            return;
                        }
                        var type = schema.getType(typeName);
                        // For now we'll say that if it's non-enum output type it can be backed
                        if (graphql_1.isOutputType(type) && !graphql_1.isEnumType(type)) {
                            for (var i = 0; i < typeSources.length; i++) {
                                var typeSource = typeSources[i];
                                if (!typeSource) {
                                    continue;
                                }
                                // If we've specified an array of "onlyTypes" to match ensure the
                                // `typeName` falls within that list.
                                if (typeSource.onlyTypes) {
                                    if (!typeSource.onlyTypes.some(function (t) {
                                        return t instanceof RegExp ? t.test(typeName) : t === typeName;
                                    })) {
                                        continue;
                                    }
                                }
                                var fileContents = typeSource.fileContents, importPath = typeSource.importPath, glob = typeSource.glob, alias = typeSource.alias, typeMatch = typeSource.typeMatch;
                                var typeRegex = typeMatch(type, defaultTypeMatcher(type)[0]);
                                var matched = firstMatch(fileContents, Array.isArray(typeRegex) ? typeRegex : [typeRegex]);
                                if (matched) {
                                    if (debug) {
                                        utils_1.log("Matched type - " + typeName + " in \"" + importPath + "\" - " + alias + "." + matched[1]);
                                    }
                                    importsMap[alias] = [importPath, glob];
                                    backingTypeMap[typeName] = alias + "." + matched[1];
                                }
                                else {
                                    if (debug) {
                                        utils_1.log("No match for " + typeName + " in \"" + importPath + "\" using " + typeRegex);
                                    }
                                }
                            }
                        }
                    });
                    if (forceImports.size > 0) {
                        console.error("Missing required typegen import: " + Array.from(forceImports));
                    }
                    imports = [];
                    Object.keys(importsMap).sort().forEach(function (alias) {
                        var _a = importsMap[alias], importPath = _a[0], glob = _a[1];
                        var safeImportPath = importPath.replace(/\\+/g, '/');
                        imports.push("import " + (glob ? "* as " : "") + alias + " from \"" + safeImportPath + "\"");
                    });
                    typegenInfo = {
                        headers: headers || [lang_1.TYPEGEN_HEADER],
                        backingTypeMap: backingTypeMap,
                        imports: imports,
                        contextType: contextType,
                    };
                    return [2 /*return*/, typegenInfo];
            }
        });
    }); };
}
exports.typegenAutoConfig = typegenAutoConfig;
function relativePathTo(absolutePath, outputPath) {
    var filename = path_1.default.basename(absolutePath).replace(/(\.d)?\.ts/, "");
    var relative = path_1.default.relative(path_1.default.dirname(outputPath), path_1.default.dirname(absolutePath));
    if (relative.indexOf(".") !== 0) {
        return "./" + path_1.default.join(relative, filename);
    }
    return path_1.default.join(relative, filename);
}
function findTypingForFile(absolutePath, pathOrModule) {
    // First try to find the "d.ts" adjacent to the file
    try {
        var typeDefPath = absolutePath.replace(path_1.default.extname(absolutePath), ".d.ts");
        require.resolve(typeDefPath);
        return typeDefPath;
    }
    catch (e) {
        console.error(e);
    }
    // TODO: need to figure out cases where it's a node module
    // and "typings" is set in the package.json
    throw new Error("Unable to find typings associated with " + pathOrModule + ", skipping");
}
var firstMatch = function (fileContents, typeRegex) {
    for (var i = 0; i < typeRegex.length; i++) {
        var regex = typeRegex[i];
        var match = regex.exec(fileContents);
        if (match) {
            return match;
        }
    }
    return null;
};
var defaultTypeMatcher = function (type) {
    return [new RegExp("(?:interface|type|class)\\s+(" + type.name + ")\\W", "g")];
};
//# sourceMappingURL=typegenAutoConfig.js.map