"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var graphql_1 = require("graphql");
var path_1 = tslib_1.__importDefault(require("path"));
var typegen_1 = require("./typegen");
var utils_1 = require("./utils");
var lang_1 = require("./lang");
var typegenAutoConfig_1 = require("./typegenAutoConfig");
var typegenFormatPrettier_1 = require("./typegenFormatPrettier");
/**
 * Passed into the SchemaBuilder, this keeps track of any necessary
 * field / type metadata we need to be aware of when building the
 * generated types and/or SDL artifact, including but not limited to:
 */
var TypegenMetadata = /** @class */ (function () {
    function TypegenMetadata(config) {
        this.config = config;
        this.typegenFile = "";
        if (config.outputs !== false && config.shouldGenerateArtifacts !== false) {
            if (config.outputs.typegen) {
                this.typegenFile = utils_1.assertAbsolutePath(config.outputs.typegen, "outputs.typegen");
            }
        }
    }
    /**
     * Generates the artifacts of the build based on what we
     * know about the schema and how it was defined.
     */
    TypegenMetadata.prototype.generateArtifacts = function (schema) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var sortedSchema, typegen, value;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sortedSchema = this.sortSchema(schema);
                        if (!this.config.outputs) return [3 /*break*/, 5];
                        if (!this.config.outputs.schema) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.writeFile("schema", this.generateSchemaFile(sortedSchema), this.config.outputs.schema)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        typegen = this.config.outputs.typegen;
                        if (!typegen) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.generateTypesFile(sortedSchema)];
                    case 3:
                        value = _a.sent();
                        return [4 /*yield*/, this.writeFile("types", value, typegen)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    TypegenMetadata.prototype.sortSchema = function (schema) {
        var sortedSchema = schema;
        if (typeof graphql_1.lexicographicSortSchema !== "undefined") {
            sortedSchema = graphql_1.lexicographicSortSchema(schema);
        }
        return sortedSchema;
    };
    TypegenMetadata.prototype.writeFile = function (type, output, filePath) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var fs, util, _a, readFile, writeFile, mkdir, formatTypegen, content, _b, _c, toSave, existing, dirPath, e_1;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (typeof filePath !== "string" || !path_1.default.isAbsolute(filePath)) {
                            return [2 /*return*/, Promise.reject(new Error("Expected an absolute path to output the GraphQL Nexus " + type + ", saw " + filePath))];
                        }
                        fs = require("fs");
                        util = require("util");
                        _a = [
                            util.promisify(fs.readFile),
                            util.promisify(fs.writeFile),
                            util.promisify(fs.mkdir),
                        ], readFile = _a[0], writeFile = _a[1], mkdir = _a[2];
                        formatTypegen = null;
                        if (typeof this.config.formatTypegen === "function") {
                            formatTypegen = this.config.formatTypegen;
                        }
                        else if (this.config.prettierConfig) {
                            formatTypegen = typegenFormatPrettier_1.typegenFormatPrettier(this.config.prettierConfig);
                        }
                        if (!(typeof formatTypegen === "function")) return [3 /*break*/, 2];
                        return [4 /*yield*/, formatTypegen(output, type)];
                    case 1:
                        _b = _d.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _b = output;
                        _d.label = 3;
                    case 3:
                        content = _b;
                        return [4 /*yield*/, Promise.all([
                                content,
                                readFile(filePath, "utf8").catch(function () { return ""; }),
                            ])];
                    case 4:
                        _c = _d.sent(), toSave = _c[0], existing = _c[1];
                        if (!(toSave !== existing)) return [3 /*break*/, 9];
                        dirPath = path_1.default.dirname(filePath);
                        _d.label = 5;
                    case 5:
                        _d.trys.push([5, 7, , 8]);
                        return [4 /*yield*/, mkdir(dirPath, { recursive: true })];
                    case 6:
                        _d.sent();
                        return [3 /*break*/, 8];
                    case 7:
                        e_1 = _d.sent();
                        if (e_1.code !== "EEXIST") {
                            throw e_1;
                        }
                        return [3 /*break*/, 8];
                    case 8: return [2 /*return*/, writeFile(filePath, toSave)];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Generates the schema, adding any directives as necessary
     */
    TypegenMetadata.prototype.generateSchemaFile = function (schema) {
        var printedSchema = graphql_1.printSchema(schema);
        return [lang_1.SDL_HEADER, printedSchema].join("\n\n");
    };
    /**
     * Generates the type definitions
     */
    TypegenMetadata.prototype.generateTypesFile = function (schema) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = typegen_1.Typegen.bind;
                        _b = [void 0, schema];
                        return [4 /*yield*/, this.getTypegenInfo(schema)];
                    case 1: return [2 /*return*/, new (_a.apply(typegen_1.Typegen, _b.concat([_c.sent()])))().print()];
                }
            });
        });
    };
    TypegenMetadata.prototype.getTypegenInfo = function (schema) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                if (this.config.typegenConfig) {
                    if (this.config.typegenAutoConfig) {
                        console.warn("Only one of typegenConfig and typegenAutoConfig should be specified, ignoring typegenConfig");
                    }
                    return [2 /*return*/, this.config.typegenConfig(schema, this.typegenFile)];
                }
                else if (this.config.typegenAutoConfig) {
                    return [2 /*return*/, typegenAutoConfig_1.typegenAutoConfig(this.config.typegenAutoConfig)(schema, this.typegenFile)];
                }
                return [2 /*return*/, {
                        headers: [lang_1.TYPEGEN_HEADER],
                        imports: [],
                        contextType: "any",
                        backingTypeMap: {},
                    }];
            });
        });
    };
    return TypegenMetadata;
}());
exports.TypegenMetadata = TypegenMetadata;
//# sourceMappingURL=typegenMetadata.js.map